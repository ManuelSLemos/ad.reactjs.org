{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2018/06/07/you-probably-dont-need-derived-state.html","result":{"data":{"markdownRemark":{"html":"<p>React 16.4 incluyó una <a href=\"/blog/2018/05/23/react-v-16-4.html#bugfix-for-getderivedstatefromprops\">solución para un error en getDerivedStateFromProps</a> que causó que algunos errores existentes en componentes de React se reprodujeran con mayor consistencia. Si esta versión expuso un caso en el que tu aplicación estaba usando un antipatrón y dejó de funcionar correctamente después de la solución, lo sentimos por la confusión creada. En este artículo, explicaremos algunos antipatrones comunes que involucran estado derivado y nuestras alternativas preferidas.</p>\n<p>Por mucho tiempo, el método de ciclo de vida <code class=\"gatsby-code-text\">componentWillReceiveProps</code> era la única forma de actualizar el estado en respuesta a un cambio en las props sin un renderizado adicional. En la versión 16.3, <a href=\"/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes\">introdujimos un reemplazo, <code class=\"gatsby-code-text\">getDerivedStateFromProps</code></a> para resolver los mismos casos de uso de forma más segura. Al mismo tiempo, nos hemos dado cuenta que se tienen muchas concepciones erróneas sobre cómo usar ambos métodos, y hemos encontrado antipatrones que terminan en errores sutiles y confusos. La solución del error en <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> en la versión 16.4 <a href=\"https://github.com/facebook/react/issues/12898\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hace que el estado derivado sea más predecible</a>, de manera que los resultados de usarlo incorrectamente sean más fáciles de detectar.</p>\n<blockquote>\n<p>Nota</p>\n<p>Todos los antipatrones descritos en este artículo se pueden aplicar tanto al antiguo <code class=\"gatsby-code-text\">componentWillReceiveProps</code> como al más nuevo <code class=\"gatsby-code-text\">getDerivedStateFromProps</code>.</p>\n</blockquote>\n<p> Este artículo cubrirá los siguientes temas:</p>\n<ul>\n<li><a href=\"#when-to-use-derived-state\">¿Cuándo usar estado derivado?</a></li>\n<li>\n<p><a href=\"#common-bugs-when-using-derived-state\">Errores comunes al usar estado derivado</a></p>\n<ul>\n<li><a href=\"#anti-pattern-unconditionally-copying-props-to-state\">Antipatrón: Copiar incondicionalmente las props al estado</a></li>\n<li><a href=\"#anti-pattern-erasing-state-when-props-change\">Antipatrón: Borrar el estado cuando cambian las props</a></li>\n</ul>\n</li>\n<li><a href=\"#preferred-solutions\">Soluciones preferidas</a></li>\n<li><a href=\"#what-about-memoization\">¿Y qué pasa con la memoización?</a></li>\n</ul>\n<h2 id=\"when-to-use-derived-state\"><a href=\"#when-to-use-derived-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Cuándo usar estado derivado? </h2>\n<p><code class=\"gatsby-code-text\">getDerivedStateFromProps</code> existe solamente con un propósito. Permite a un componente actualizar su estado interno como resultado de <strong>cambios en las props</strong>. Nuestro artículo anterior en el blog proporcionaba algunos ejemplos, como <a href=\"/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\">guardar la dirección actual del desplazamiento con base en una prop de los cambios de intervalos de desplazamiento</a> o <a href=\"/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change\">cargar datos externos especificados por una prop fuente</a>.</p>\n<p>No proporcionamos muchos ejemplos, porque por regla general, <strong>el estado derivado debe ser usado con moderación</strong>. Todos los problemas con el estado derivado que hemos visto pueden reducirse en última instancia o bien (1) a actualizar incondicionalmente el estado a partir de las props o (2) a actualizar el estado cuando las props y el estado no coinciden. (Veremos ambos con mayor detalle más adelante).</p>\n<ul>\n<li>Si estás usando estado derivado para memoizar algún cálculo basado solo en las props actuales, no necesitas estado derivado. Ve debajo <a href=\"#what-about-memoization\">¿Y qué pasa con la memoización?</a>.</li>\n<li>Si estás actualizando el estado derivado incondicionalmente o actualizándolo cuando las props y el estado no coinciden, es probable que tu componente reinicie su estado con demasiada frecuencia. Continúa leyendo para mayores detalles.</li>\n</ul>\n<h2 id=\"common-bugs-when-using-derived-state\"><a href=\"#common-bugs-when-using-derived-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Errores comunes cuando se usa estado derivado </h2>\n<p>Los términos <a href=\"/docs/forms.html#controlled-components\">«controlado»</a> y <a href=\"/docs/uncontrolled-components.html\">«no controlado»</a> a menudo hacen referencia a las entradas de un formulario, pero también pueden describir donde residen los datos de un componente cualquiera. Los datos que se pasan como props se pueden ver como <strong>controlados</strong> (porque el componente padre <em>controla</em> los datos). Los datos que existen solo en el estado interno se pueden ver como <strong>no controlados</strong> (porque el padre no puede cambiarlos directamente).</p>\n<p>El error más común con el estado derivado es mezclar ambos. Cuando un valor del estado derivado también se actualiza por llamadas a <code class=\"gatsby-code-text\">setState</code>, no existe una sola fuente de verdad para los datos. El <a href=\"/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change\">ejemplo de la carga de datos externos</a> que se mencionó arriba puede parecer similar, pero es diferente en varias aspectos importantes. En el ejemplo de la carga, hay una clara fuente de verdad tanto para la prop «fuente» y el estado «de carga». Cuando la prop fuente cambia, el estado de carga <strong>siempre</strong> debería sobrescribirse. A la inversa, el estado se sobrescribe solo cuando la prop <strong>cambia</strong> y de otra manera es manejada por el componente.</p>\n<p>Los problemas surgen cuando cualquiera de estas restricciones cambian. Esto suele suceder de dos formas. Veamos ambas.</p>\n<h3 id=\"anti-pattern-unconditionally-copying-props-to-state\"><a href=\"#anti-pattern-unconditionally-copying-props-to-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Antipatrón: Copiar incondicionalmente las props al estado </h3>\n<p>Una concepción errónea que se encuentra a menudo es que <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> y <code class=\"gatsby-code-text\">componentWillReceiveProps</code> se llaman solo cuando las props «cambian». Estos métodos de ciclo de vida se llaman cada vez que el componente padre se vuelve a renderizar, sin importar si las props son «diferentes» a las anteriores. Debido a esto, siempre ha sido inseguro sobrescribir <em>incondicionalmente</em> el estado usando cualquiera de estos métodos de ciclo de vida. <strong>Hacerlo causará que las actualizaciones al estado se pierdan.</strong></p>\n<p>Consideremos un ejemplo para demostrar el problema. Se tiene un componente <code class=\"gatsby-code-text\">EmailInput</code> que «refleja» una prop email en el estado:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ¡Esto borrará cualquier actualización del estado local!</span>\n    <span class=\"token comment\">// No lo hagas.</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> nextProps<span class=\"token punctuation\">.</span>email <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Al principio, este componente puede que sea vea bien. El estado se inicializa con el valor especificado por las props y se actualiza cuando escribimos en el <code class=\"gatsby-code-text\">&lt;input&gt;</code>. Pero si nuestro componente padre se rerenderiza, ¡cualquier cosa que hayamos escrito en el <code class=\"gatsby-code-text\">&lt;input&gt;</code> se perderá! (<a href=\"https://codesandbox.io/s/m3w9zn1z8x\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Encuentra un ejemplo en esta demo</a>). Esto es cierto incluso si fuéramos a comparar <code class=\"gatsby-code-text\">nextProps.email !== this.state.email</code> antes de reiniciar.</p>\n<p>En este ejemplo sencillo, para solucionar esto se puede añadir <code class=\"gatsby-code-text\">shouldComponenteUpdate</code> para rerenderizar solo cuando la prop email ha cambiado. Sin embargo, en la práctica, los componentes usualmente aceptan múltiples props, otra prop que cambie aún podría causar un rerenderizado y un reinicio inadecuado. Las props que son funciones u objetos a menudo se crean en línea, dificultando la implementación de <code class=\"gatsby-code-text\">shouldComponentUpdate</code> que devuelva verdadero de forma confiable solo cuando un cambio material ha ocurrido. <a href=\"https://codesandbox.io/s/jl0w6r9w59\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Aquí hay una demo que muestra cómo ocurre.</a> Como resultado, <code class=\"gatsby-code-text\">shouldComponentUpdate</code> es mejor usarlo como una optimización del rendimiento, no para asegurar la corrección del estado derivado.</p>\n<p>Esperamos que quede claro en este punto por qué <strong>es una mala idea copiar incondicionalmente las props al estado</strong>. Antes de analizar posibles soluciones, miremos otro patrón problemático que guarda relación con este: ¿Y si fuéramos a actualizar el estado solamente cuando la prop email cambia?</p>\n<h3 id=\"anti-pattern-erasing-state-when-props-change\"><a href=\"#anti-pattern-erasing-state-when-props-change\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Antipatrón: Borrar el estado cuando las props cambian </h3>\n<p>Continuando con el ejemplo de arriba, podríamos evitar accidentalmente borrar el estado si solo actualizamos cuando <code class=\"gatsby-code-text\">props.email</code> cambia:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Cada vez que props.email cambia, actualiza el estado.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>email <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        email<span class=\"token operator\">:</span> nextProps<span class=\"token punctuation\">.</span>email\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Nota</p>\n<p>Aún cuando el ejemplo de arriba muestra <code class=\"gatsby-code-text\">componentWillReceiveProps</code>, el mismo antipatrón se aplica a  <code class=\"gatsby-code-text\">getDerivedStateFromProps</code>.</p>\n</blockquote>\n<p>Acabamos de hacer una gran mejora. Ahora nuestro componente borrará lo que hemos escrito solo cuando las props cambian en realidad.</p>\n<p>Aún hay un problema sutil. Imagina una aplicación de gestión de contraseñas que use el componente de entrada de arriba. Cuando se navega entre los detalles para dos cuentas con el mismo correo, la entrada fallará en reiniciarse. ¡Esto ocurre porque el valor de la prop que se pasa al componente sería el mismo para ambas cuentas! Esto sería una sorpresa para el usuario, dado que un cambio sin guardar en una cuenta parecería afectar otras cuentas que comparten el mismo correo. (<a href=\"https://codesandbox.io/s/mz2lnkjkrx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mira la demo aquí</a>).</p>\n<p>Este es un diseño fallido desde la base, pero es también un error fácil de cometer. (<a href=\"https://twitter.com/brian_d_vaughn/status/959600888242307072\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">¡A mí también me pasó!</a>). Afortunadamente hay dos alternativas que funcionan mejor. La clave para ambas es que <strong>para cualquier dato, necesitas elegir un solo componente que lo posea como la fuente de verdad y evita duplicarlo en otros componentes.</strong> Veamos cada una de las alternativas.</p>\n<h2 id=\"preferred-solutions\"><a href=\"#preferred-solutions\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Soluciones preferidas </h2>\n<h3 id=\"recommendation-fully-controlled-component\"><a href=\"#recommendation-fully-controlled-component\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomendación: Componente completamente controlado </h3>\n<p>Una forma de evitar los problemas mencionados anteriormente consiste en eliminar completamente el estado de nuestro componente. Si la dirección de correo solo existe como una prop, entonces no tenemos que preocuparnos por los conflictos con el estado. Podríamos incluso convertir <code class=\"gatsby-code-text\">EmailInput</code> a un componente de función más ligero:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">EmailInput</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>onChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Este enforque simplifica la implementación de nuestro componente, pero si todavía quisiéramos almacenar un valor a modo de borrador, el componente padre del formulario necesitaría hacerlo ahora manualmente. (<a href=\"https://codesandbox.io/s/7154w1l551\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Haz clic aquí para ver una demo de este patrón.</a>)</p>\n<h3 id=\"recommendation-fully-uncontrolled-component-with-a-key\"><a href=\"#recommendation-fully-uncontrolled-component-with-a-key\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomendación: Componente completamente no controlado con una <code class=\"gatsby-code-text\">key</code> </h3>\n<p>Otra alternativa sería que nuestro componente se encargara completamente del estado del «borrador» del correo. En este caso, nuestro componente seguiría aceptando una prop para el valor <em>inicial</em>, pero ignoraría los cambios sucesivos a esa prop:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Para poder reiniciar el valor cuando nos movemos a un elemento diferente (como en el ejemplo del gestor de contraseñas), podemos utilizar el atributo especial de React llamado <code class=\"gatsby-code-text\">key</code>. Cuando un atributo <code class=\"gatsby-code-text\">key</code> cambia, React <a href=\"/docs/reconciliation.html#keys\"><em>creará</em> una nueva instancia del componente en lugar de <em>actualizar</em> el actual</a>. El atributo <code class=\"gatsby-code-text\">key</code> se utiliza a menudo para listas dinámicas, pero también es útil aquí. En nuestro caso, podríamos utilizar el ID de usuario para recrear el campo email cada vez que se seleccione un nuevo usuario:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">EmailInput</span></span>\n  <span class=\"token attr-name\">defaultEmail</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span>\n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>Cada vez que el ID cambia, el componente <code class=\"gatsby-code-text\">EmailInput</code> será recreado y su estado se reiniciará al último valor <code class=\"gatsby-code-text\">defaultEmail</code>. (<a href=\"https://codesandbox.io/s/6v1znlxyxn\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Haz clic aquí para ver una demo de este patrón.</a>) Con este enfoque, no tienes que añadir <code class=\"gatsby-code-text\">key</code> a cada campo. Tendría más sentido poner un atributo <code class=\"gatsby-code-text\">key</code> en todo el formulario. Cada vez que el campo <code class=\"gatsby-code-text\">key</code> cambia, todos los componentes dentro del formulario serán recreados con un estado nuevo.</p>\n<p>En la mayoría de los casos, este es la mejor forma de manejar estado que necesita reiniciarse.</p>\n<blockquote>\n<p>Nota</p>\n<p>Si bien esto puede parecer lento, la diferencia en el rendimiento usualmente es insignificante. Usar un atributo <code class=\"gatsby-code-text\">key</code> incluso puede ser más rápido si los componentes tienen una lógica compleja que se ejecuta en las actualizaciones, dado que se evita ejecutar el algoritmo de <em>diferenciación</em> para ese subárbol.</p>\n</blockquote>\n<h4 id=\"alternative-1-reset-uncontrolled-component-with-an-id-prop\"><a href=\"#alternative-1-reset-uncontrolled-component-with-an-id-prop\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Alternativa 1: Reiniciar un componente controlado con una prop ID </h4>\n<p>Si <code class=\"gatsby-code-text\">key</code> no funciona por alguna razón (quizá la inicialización del componente es muy costosa), una solución que funciona, aunque engorrosa, consistiría en observar los cambios a «userID» en <code class=\"gatsby-code-text\">getDerivedStateFromProps</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail<span class=\"token punctuation\">,</span>\n    prevPropsUserID<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> state</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Cada vez que el usuario actual cambia,</span>\n    <span class=\"token comment\">// Reiniciar cualquier parte del estado que esté atada a ese usuario.</span>\n    <span class=\"token comment\">// En este ejemplo, es solo email.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>userID <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>prevPropsUserID<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        prevPropsUserID<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">,</span>\n        email<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>defaultEmail\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Esto también proporciona la flexibilidad de solo reiniciar partes del estado interno de nuestro componente si elegimos que así sea. (<a href=\"https://codesandbox.io/s/rjyvp7l3rq\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Haz clic aquí para ver una demo de este patrón.</a>)</p>\n<blockquote>\n<p>Nota</p>\n<p>Si bien el ejemplo de arriba muestra <code class=\"gatsby-code-text\">getDerivedStateFromProps</code>, la misma técnica se puede usar con <code class=\"gatsby-code-text\">componentWillReceiveProps</code>.</p>\n</blockquote>\n<h4 id=\"alternative-2-reset-uncontrolled-component-with-an-instance-method\"><a href=\"#alternative-2-reset-uncontrolled-component-with-an-instance-method\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Alternativa 2: Reiniciar un componente no controlado con un método de instancia </h4>\n<p>En contadas ocasiones, puedes necesitar reiniciar el estado incluso si no hay un ID apropiado para usarse como <code class=\"gatsby-code-text\">key</code>. Una solución consiste en reiniciar el atributo <code class=\"gatsby-code-text\">key</code> con un valor aleatorio o un número que se autoincremente cada vez que se quiera reiniciar el estado. Otra alternativa viable consiste en exponer un método de instancia para reiniciar imperativamente el estado interno:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">resetEmailForNewUser</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newEmail</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token operator\">:</span> newEmail <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>El componente padre del formulario podría entonces <a href=\"/docs/glossary.html#refs\">usar una <code class=\"gatsby-code-text\">ref</code> para llamar este método</a>. (<a href=\"https://codesandbox.io/s/l70krvpykl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Haz clic aquí para ver una demo de este patrón.</a>)</p>\n<p>Las refs pueden ser útiles en algunos casos como este, pero generalmente te recomendamos usarlas con moderación. Incluso en la demo, este método imperativo no es ideal, porque ocurrirán dos renderizados en lugar de uno.</p>\n<hr>\n<h3 id=\"recap\"><a href=\"#recap\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resumiendo </h3>\n<p>Para resumir, cuando se diseña un componente, es importante decidir si sus datos serán controlados o no controlados.</p>\n<p>En lugar de intentar <strong>«reflejar» el valor de una prop en el estado</strong>, haz que el componente sea <strong>controlado</strong>, y consolidar los dos valores divergentes en el estado de un componente padre. Por ejemplo, en lugar de que un hijo acepte un <code class=\"gatsby-code-text\">props.valor</code> confirmado y monitoree un <code class=\"gatsby-code-text\">state.valor</code> «temporal», que el padre maneje tanto <code class=\"gatsby-code-text\">state.valorTemporal</code> y <code class=\"gatsby-code-text\">state.valorConfirmado</code> y controle el valor del hijo directamente. Esto hace que el flujo de datos se más explícito y predecible.</p>\n<p>Para componentes <strong>no controlados</strong>, si intentas reiniciar el estado cuando una prop en particular (usualmente un ID) cambia, tienes varias opciones:</p>\n<ul>\n<li><strong>Recomendación: Reiniciar <em>todo el estado interno</em>, usar el atributo <code class=\"gatsby-code-text\">key</code>.</strong></li>\n<li>Alternativa 1: Reiniciar <em>solo algunos campos de estado</em>, monitorear cambios en una propiedad especial (p. ej. <code class=\"gatsby-code-text\">props.userID</code>).</li>\n<li>Alternativa 2: Puedes considerar también recurrir a un método de instancia imperativo usando refs.</li>\n</ul>\n<h2 id=\"what-about-memoization\"><a href=\"#what-about-memoization\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Y qué pasa con la memoización? </h2>\n<p>También hemos visto el uso de estado derivado para asegurar que un valor costoso que se usa en <code class=\"gatsby-code-text\">render</code> sea recalculado solo cuando las entradas cambian. Esta técnica se conoce como <a href=\"https://en.wikipedia.org/wiki/Memoization\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">memoización</a>.</p>\n<p>El uso de estado derivado para memoización no está necesariamente mal, pero a menudo no es la mejor solución. Existe una complejidad intrínseca en el manejo de estado derivado, y esta complejidad crece con cada propiedad adicional. Por ejemplo, si añadimos un segundo campo derivado al estado de nuestro componente, entonces nuestra implementación necesitaría monitorear independientemente los cambios de ambos.</p>\n<p>Veamos un ejemplo de un componente que toma una prop (una lista de elementos) y renderiza los elementos que cumplan una consulta de búsqueda introducida por el usuario. Podríamos usar estado derivado para almacenar la lista filtrada:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    filterText<span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// *******************************************************</span>\n  <span class=\"token comment\">// NOTA: este ejemplo NO usa el enfoque recomendado.</span>\n  <span class=\"token comment\">// Consulta los ejemplos de abajo para ver nuestras recomendaciones.</span>\n  <span class=\"token comment\">// *******************************************************</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> state</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Volver a ejcutar el filtrado cada vez que la lista o el texto del filtro cambian.</span>\n    <span class=\"token comment\">// Observa que necesitamos almacenar prevPropsList y prevFilterText para detectar cambios.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      props<span class=\"token punctuation\">.</span>list <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>prevPropsList <span class=\"token operator\">||</span>\n      state<span class=\"token punctuation\">.</span>prevFilterText <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>filterText\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        prevPropsList<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">,</span>\n        prevFilterText<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">,</span>\n        filteredList<span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Esta implementación evita recalcular <code class=\"gatsby-code-text\">filteredList</code> con más frecuencia de la necesaria. Pero es demasiado complicada, porque tiene que monitorerar y detectar cambios independientemente tanto en las props como en el estado para poder actualizar adecuadamente la lista filtrada. En este ejemplo, podríamos lograr una simplificación si usáramos <code class=\"gatsby-code-text\">PureComponent</code> y moviéramos la operación de filtrado al método render:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// Un PureComponent solo se rerenderiza si al menos un valor de estado o prop cambia.</span>\n<span class=\"token comment\">// Se determina si cambió haciendo una comparación superficial de los elementos del estado y las props.</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PureComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// El estado solo necesita almacenar el texto del filtro actual:</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    filterText<span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// El método render en este PureComponent se llama solo si</span>\n    <span class=\"token comment\">// props.list o state.filterText han cambiado.</span>\n    <span class=\"token keyword\">const</span> filteredList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>\n      <span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>El enfoque de arriba es mucho más claro y simple que la versión con estado derivado. En ocasiones, sin embargo, no será lo suficientemente bueno. El filtrado pueder ser lento para listas grandes, y <code class=\"gatsby-code-text\">PureComponent</code> no prevendría que se rerenderizara si otra prop cambiara. Para manejar ambas preocupaciones, podríamos añadir una utilidad de memoización para evitar refiltrar innecesariamente nuestra lista:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">import</span> memoize <span class=\"token keyword\">from</span> <span class=\"token string\">\"memoize-one\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// El estado solo necesita almacenar el texto del filtro actual:</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> filterText<span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Volver a ejecutar el filtrado cada vez que cambia la lista o el texto del filtro:</span>\n  filter <span class=\"token operator\">=</span> <span class=\"token function\">memoize</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">list<span class=\"token punctuation\">,</span> filterText</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token operator\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Calcular la última lista filtrada. Si estos argumentos no han cambiado desde </span>\n    <span class=\"token comment\">// el último renderizado, `memoize-one` reutilizará el último valor de retorno.</span>\n    <span class=\"token keyword\">const</span> filteredList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Fragment</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>¡Esto es mucho más simple y el rendimiento es tan bueno como el de la versión con estado derivado!</p>\n<p>Cuando utilizamos memoización, recuerda un par de restricciones:</p>\n<ol>\n<li>En la mayoría de los casos, querrás <strong>adjuntar la función memoizada a una instancia de componente</strong>. Esto previene que múltiples intancias de un componente se reinicien entre ellas las llaves memoizadas.</li>\n<li>Normalmente querrás usar una utilidad de memoización con un <strong>tamaño limitado de caché</strong> para prevenir fugas de memoria con el tiempo. (En el ejemplo de arriba usamos <code class=\"gatsby-code-text\">memoized-one</code>, porque solo guarda en caché los argumentos y el resultado más recientes).</li>\n<li>Ninguna de las implementaciones mostradas en esta sección funcionarán si <code class=\"gatsby-code-text\">props.list</code> se recrea cada vez que el componente padre se renderiza. Pero en la mayoría de los casos, esta configuración es apropiada.</li>\n</ol>\n<h2 id=\"in-closing\"><a href=\"#in-closing\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusión </h2>\n<p>En aplicaciones del mundo real, los componentes a menudo contienen una mezcla de comportamientos controlados y no controlados. ¡Eso está bien! Si cada valor tiene una clara fuente de verdad, puedes evitar los antipatrones que se mencionaron anteriormente.</p>\n<p>También vale la pena reiterar que <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> (y en general el estado derivado) es una funcionalidad avanzada y debe usarse con moderación dada su complejidad. Si tu caso de uso se aparta de estos patrones, por favor, ¡compártelo con nosotros en <a href=\"https://github.com/reactjs/reactjs.org/issues/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub</a> o <a href=\"https://twitter.com/reactjs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Twitter</a>!</p>","excerpt":"React 16.4 incluyó una solución para un error en getDerivedStateFromProps que causó que algunos errores existentes en componentes de React se reprodujeran con mayor consistencia. Si esta versión expuso un caso en el que tu aplicación estaba usando un antipatrón y dejó de funcionar correctamente después de la solución, lo sentimos por la confusión creada. En este artículo, explicaremos algunos antipatrones comunes que involucran estado derivado y nuestras alternativas preferidas. Por mucho tiempo…","frontmatter":{"title":"Probablemente no necesitas estado derivado","next":null,"prev":null,"author":[{"frontmatter":{"name":"Brian Vaughn","url":"https://github.com/bvaughn"}}]},"fields":{"date":"June 06, 2018","path":"content/blog/2018-06-07-you-probably-dont-need-derived-state.md","slug":"/blog/2018/06/07/you-probably-dont-need-derived-state.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}},{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"Preparing for the Future with React Prereleases"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"Introduciendo las nuevas React DevTools"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 y Actualización de la Hoja de Ruta"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}},{"node":{"frontmatter":{"title":"¿Ya está traducido React? ¡Sí! Sim! はい！"},"fields":{"slug":"/blog/2019/02/23/is-react-translated-yet.html"}}},{"node":{"frontmatter":{"title":"React v16.8: The One With Hooks"},"fields":{"slug":"/blog/2019/02/06/react-v16.8.0.html"}}},{"node":{"frontmatter":{"title":"React v16.7: No, este no es el que tiene Hooks"},"fields":{"slug":"/blog/2018/12/19/react-v-16-7.html"}}},{"node":{"frontmatter":{"title":"React 16.x Roadmap"},"fields":{"slug":"/blog/2018/11/27/react-16-roadmap.html"}}},{"node":{"frontmatter":{"title":"React Conf recap: Hooks, Suspense, and Concurrent Rendering"},"fields":{"slug":"/blog/2018/11/13/react-conf-recap.html"}}}]}},"pageContext":{"slug":"/blog/2018/06/07/you-probably-dont-need-derived-state.html"}}}